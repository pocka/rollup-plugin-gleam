//! Rollup plugin for Gleam language.
//
//! SPDX-FileCopyrightText: 2024 Shota FUJI <pockawoooh@gmail.com>
//! SPDX-License-Identifier: Apache-2.0

import { execFile } from "node:child_process";
import { readFile } from "node:fs/promises";
import * as path from "node:path";
import { promisify } from "node:util";
import { fileURLToPath } from "node:url";

import * as toml from "js-toml";
import type { Plugin } from "rollup";

interface GleamTOML {
	name: string;
	version: string;
}

function isGleamTOML(x: unknown): x is GleamTOML {
	if (typeof x !== "object" || !x) {
		return false;
	}

	if (!("name" in x && typeof x.name === "string" && x.name)) {
		return false;
	}

	if (!("version" in x && typeof x.version === "string" && x.version)) {
		return false;
	}

	return true;
}

export interface GleamPluginOptions {
	/**
	 * Path to `gleam.toml` file.
	 * This plugin looks for source directory and build directory based on this file location.
	 *
	 * Current working directory will be used to resolve relative paths.
	 *
	 * @default "./gleam.toml"
	 */
	gleamToml?: URL | string;

	/**
	 * Path to or name of the Gleam binary file to invoke.
	 * @default "gleam"
	 */
	bin?: string;

	buildOptions?: {
		/**
		 * Emit compile time warnings as errors.
		 * Enables `--warnings-as-errors` CLI flag.
		 */
		warningsAsErrors?: boolean;
	};
}

export function gleam({
	bin = "gleam",
	buildOptions = {},
	gleamToml: gleamTomlPathOrUrl = "./gleam.toml",
}: GleamPluginOptions = {}): Plugin {
	/**
	 * Parsed contents of `gleam.toml`.
	 */
	let gleamToml: GleamTOML | null = null;

	const projectRoot =
		typeof gleamTomlPathOrUrl === "string"
			? path.resolve(gleamTomlPathOrUrl, "..")
			: fileURLToPath(new URL("./", gleamTomlPathOrUrl));

	// Gleam expects a project to have `src/` directory at project root.
	const srcDir = path.resolve(projectRoot, "src");

	// Gleam compiler outputs artifacts under `build/` directory at project root.
	// Directory structure inside is not documentated, but this is the only way
	// to access built JS files. There is no way to specify output directory also.
	const jsOutDir = path.resolve(projectRoot, "build/dev/javascript");

	const buildCommandArgs = ["build", "--target", "javascript"];
	if (buildOptions.warningsAsErrors) {
		buildCommandArgs.push("--warnings-as-errors");
	}

	// Build command won't change during the plugin's lifetime.
	// It's fine to bind everything upfront.
	const buildProject = promisify(execFile).bind(null, bin, buildCommandArgs, {
		cwd: projectRoot,
	});

	return {
		name: "gleam",
		async buildStart() {
			// Changes to `gleam.toml` should trigger rerun of this hook.
			// Otherwise, if `name` field got changed for example, Rollup tries to access nonexistent
			// files based on an old name (build/dev/javascript/old_name/foo.mjs).
			this.addWatchFile(
				typeof gleamTomlPathOrUrl === "string"
					? gleamTomlPathOrUrl
					: fileURLToPath(gleamTomlPathOrUrl),
			);

			const parsed = toml.load(await readFile(gleamTomlPathOrUrl, { encoding: "utf8" }));
			if (!isGleamTOML(parsed)) {
				// TypeScript can't narrow types using `never`. Putting `return` after this line
				// triggers `Unreachable code detected.` so we have to *return never*.
				// <https://github.com/microsoft/TypeScript/issues/12825>
				// Following code contains the same workaround for this reason.
				return this.error(`gleam.toml does not comform to official schema.`);
			}

			gleamToml = parsed;
		},
		async watchChange(id, _change) {
			// Whenever indirectly imported .gleam file is changed, build the whole project.
			// Gleam compiler does the incremental compilation (we don't have a way to partially compile.)
			if (id.endsWith(".gleam")) {
				await buildProject();
				return;
			}
		},
		async transform(_code, id) {
			// Associate .mjs file generated by Gleam compiler to its source .gleam file.
			// This enables changing **imported** .gleam files to trigger rebuild.
			if (id.startsWith(jsOutDir) && id.endsWith(".mjs")) {
				if (!gleamToml) {
					this.warn(
						"Detected access to Gleam build artifacts without `gleam.toml` loaded.",
					);
					return null;
				}

				if (id.endsWith("/gleam.mjs")) {
					// Skip if the file is Gleam runtime one (no corresponding .gleam file).
					return null;
				}

				if (!id.startsWith(path.resolve(jsOutDir, gleamToml.name))) {
					// Skip third-party packages, as users are not supposed to edit those source files directly.
					return null;
				}

				/**
				 * Module namespace and module name.
				 *
				 * "build/dev/javascript/my_package/foo/bar.mjs"
				 * -> "foo/bar"
				 */
				const modulePath = id
					// `+1` ... removing path separator
					.slice(path.resolve(jsOutDir, gleamToml.name).length + 1)
					.replace(/\.mjs$/, "");

				/**
				 * Gleam source code file that produces this .mjs file.
				 *
				 * "build/dev/javascript/my_package/foo/bar.mjs"
				 * -> "src/foo/bar.gleam"
				 */
				const gleamSrc = path.resolve(srcDir, modulePath) + ".gleam";
				this.addWatchFile(gleamSrc);

				// Do not touch code. Only important thing here is `addWatchFiles(gleamSrc)`.
				return null;
			}

			// .gleam files imported by non-Gleam modules (e.g. .js, .ts) run through this branch.
			// This branch triggers a build then returns proxy code that re-exports everything from
			// the generated .mjs file.
			if (id.endsWith(".gleam")) {
				if (!gleamToml) {
					return this.error(
						"Unable to resolve transpiled Gleam file without `gleam.toml`.",
					);
				}

				const absPath = path.resolve(srcDir, id);
				if (!absPath.startsWith(srcDir)) {
					this.error("Gleam files must be inside the src/ directory.");
				}

				const modulePath = absPath
					// `+1` ... removing path separator
					.slice(srcDir.length + 1)
					.replace(/\.gleam$/, ".mjs");

				const transpiledMjsPath = path.resolve(jsOutDir, gleamToml.name, modulePath);

				await buildProject();

				return {
					code: `export * from ${JSON.stringify(transpiledMjsPath)}`,
				};
			}
		},
	};
}

export default gleam;
